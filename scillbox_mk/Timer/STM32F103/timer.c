#include "timer.h"

void Time4_init (void)        //Функция настройка таймера 
{
  // Тактирование
  RCC_APB1PeriphClockCmd (RCC_APB1Periph_TIM4, ENABLE);
  // Заполнение структур таймера в режиме счетчика
  TIM_TimeBaseInitTypeDef TIM4_init;
  TIM4_init.TIM_ClockDivision = TIM_CKD_DIV1; //Делитель входной частоты для внутренних нужд таймера.
  TIM4_init.TIM_CounterMode = TIM_CounterMode_Up; //Режим счетчика, определяет в какую сторону считать
                    /*Up – прямой счет.
                      Down – реверсивный счет.
                      Center Aligned mode 1 – двунаправленный счет, прерывание генерируется в момент, когда счетчик считает в обратную сторону и доходит до 0.
                      Center Aligned mode 2 – двунаправленный счет, прерывание генерируется, когда счетчик считает в прямом направлении и достигает значения перезагрузки.
                      Center Aligned mode 3 – двунаправленный счет, прерывание генерируется, в обоих случаях - при достижении 0 и значения перезагрузки.*/
                    
  TIM4_init.TIM_Period = 60000;  //Регистр перезагрузки (не более 65536, так как 16 разрядный)
  TIM4_init.TIM_Prescaler = 3599;  //Предделитель зависит от тактовой частоты (не более 65536, так как 16 разрядный)
  TIM4_init.TIM_RepetitionCounter = 0;    
                    /*Регистр счетчика повторов. Присутствует не во всех таймерах. Счетчик повторов считает импульсы событий на выходе таймера 
                    и при достижении значения регистра повторов сбрасывается и формирует реальное событие. 
                    Т.е. он делит частоту генерации событий (прерываний) таймера.*/


  /*-----------Формула расчета-------------
  Update_event =TIM_CLK/ ((PSC+1)*(ARR+1)*(RCR+1))
  TIM_CLK = timer clock input
  PSC =16-bit prescaller register - предделитель. Предделитель делит частоту тактирования таймера, поступающую на основной счетчик
  ARR = 16/32-bit Autoreload register - Регистр перезагрузки
  RCR = 16-bit repetition counter   - счетчик повторов
  -----------Формула расчета-------------*/

  /*--------------Пример расчета------------------
  Сделаем практическую задачу. Установим конфигурацию таймера 1, обеспечивающую циклические прерывания с периодом 0,5 секунд. 
  Частота тактирования у нас 72 мГц. Превратим ее с помощью предделителя в круглое значение.
  Например, если задать 720 – 1 = 719, то частота после предделителя будет 72 000 000 / 720 = 100 000 Гц, или период 10 мкс.
  Если в регистр перезагрузки задать значение 50 000, то получим требуемый период 0,5 секунд.
  
  Если нужен период в 3 секунды, то 3 секунды это 3 000 000 мкс => 3 000 000/10 => в регистр перезагрузки задать значение 300 000. Не пройдет
  Возьмем Регистр перезагрузки = 60000. => период = 3 сек/60000 = 0,00005 сек.=> частота = 1/0,00005сек = 20 000 Гц => предделитель=72 000 000/20 000 Гц= 3600 -1 = 3599
  --------------Пример расчета------------------*/


  TIM_TimeBaseInit(TIM4, &TIM4_init);
  // Наcтройка разрешения прерывания таймера
  TIM_ITConfig (TIM4, TIM_IT_Update, ENABLE);
  // Запуск таймера
  TIM_Cmd (TIM4, ENABLE);

  NVIC_EnableIRQ(TIM4_IRQn); //Обработчик прерываний 
}

void TIM4_IRQHandler (void)
{
  if (TIM_GetITStatus (TIM4,TIM_IT_Update) != RESET)
  {
    TIM_ClearITPendingBit(TIM4,TIM_IT_Update);
    GPIOA->ODR ^= GPIO_ODR_ODR5;
  }
  //if (delay_cnt!=0){
	// delay_cnt--;
	//}
}
